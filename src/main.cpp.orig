#include <cstdio>
#include <memory>
#include <string>
#include <vector>
#include <forward_list>
#include <unordered_map>

#include <SFML/System.hpp>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>

#include "helper.hpp"
#include "object.hpp"

using namespace std;

static const Poly wall = {
	Vec2(200, 200),
	Vec2(200, 400),
	Vec2(240, 410),
	Vec2(400, 200)
};


class Laser : public Object {
public:
	Laser(Vec2 pos) {
		init("media/laser.png");
		setPosition(pos);
	}
	virtual bool update() {
		move(vel);
		updateCollisionPoly();

		Vec2 n, v;
		float d = checkCollision(wall, poly, n, v);
		if (d > 0) {
			move(n * -d);
			n *= n.x * vel.x + n.y * vel.y;
			vel -= 2.0f * (vel - n);
			vel = - vel;
			rotate(-atan2(vel.x, vel.y) * 180 / M_PI);
		}

		if (getPosition().y < -10) return false;
		return true;
	}
private:
	Vec2 vel = {0, -12};

	virtual const Poly& getCollisionModel() {
		static const Poly model = {
			Vec2(0.5, 2.5),
			Vec2(0.5, -2.5),
			Vec2(-0.5, -2.5),
			Vec2(-0.5, 2.5),
		};
		return model;
	}
};


forward_list<unique_ptr<Laser>> lasers;




class Player : public Object {
public:
	virtual void init() {
		Object::init("media/ship.png");
		setPosition(400, 500);
	}

	virtual bool update() {

		float joy_x = sf::Joystick::getAxisPosition(0, sf::Joystick::X);
		float joy_y = sf::Joystick::getAxisPosition(0, sf::Joystick::Y);
		Vec2 mov;
		mov.x = (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) or joy_x > 50)
				-(sf::Keyboard::isKeyPressed(sf::Keyboard::Left) or joy_x < -50);
		mov.y = (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) or joy_y > 50)
				-(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) or joy_y < -50);
		Vec2 pos = getPosition();
		pos += mov * 3.0f;
		pos.x = min(pos.x, 784.0f);
		pos.x = max(pos.x, 16.0f);
		pos.y = min(pos.y, 584.0f);
		pos.y = max(pos.y, 16.0f);
		setPosition(pos);
		updateCollisionPoly();


		bool shoot = sf::Joystick::isButtonPressed(0, 0)
			| sf::Keyboard::isKeyPressed(sf::Keyboard::X);
		if (shoot && !(tick % 10)) {
			lasers.push_front(unique_ptr<Laser>(new Laser(pos + Vec2(0, -10))));
		}

		setFrame(tick++ / 4 % 2);

		return true;
	}


	virtual void draw(sf::RenderWindow& win) {

		Vec2 n, v;
		float d = checkCollision(wall, poly, n, v);
		if (d > 0) move(n * -d);

		win.draw(*this);
		drawPoly(win, poly);
		drawPoly(win, wall);
	};


private:
	virtual const Poly& getCollisionModel() {
		static const Poly model = {
			Vec2(4, 4),
			Vec2(4, 1),
			Vec2(1, -4),
			Vec2(-1, -4),
			Vec2(-4, 1),
			Vec2(-4, 4),
		};
		return model;
	}

	size_t tick = 0;
};


Player player;



static const vector<Poly> tileData = {
	{ },
	{ Vec2(-1, -1), Vec2(-1, 1), Vec2(1, 1), Vec2(1, -1) },
	{ Vec2(-1, 1), Vec2(1, 1), Vec2(1, -1) },
	{ Vec2(-1, -1), Vec2(1, 1), Vec2(1, -1) },
	{ Vec2(-1, -1), Vec2(-1, 1), Vec2(1, -1) },
	{ Vec2(-1, -1), Vec2(-1, 1), Vec2(1, 1) }
};

class Walls {
public:
	Walls() {

		tiles.resize(width * height);
		for (int& t : tiles) t = rand() % 4;

	}

	void update() {

	}

	void draw(sf::RenderWindow& win) {

		for (

	}

private:
	const int width = 25;
	const int height = 25;
	vector<int> tiles;



};
Walls walls;



void update() {
	updateList(lasers);
	player.update();
}


void draw(sf::RenderWindow& win) {
	for (auto& laser: lasers) laser->draw(win);
	player.draw(win);
}


int main(int argc, char** argv) {

	sf::RenderWindow window(sf::VideoMode(800, 600), "sfml",
		sf::Style::Titlebar || sf::Style::Close);
	window.setFramerateLimit(60);


	player.init();


	while (window.isOpen()) {
		sf::Event e;
		while (window.pollEvent(e)) {
			switch (e.type) {
			case sf::Event::Closed:
				window.close();
				break;

			case sf::Event::KeyPressed:
				if (e.key.code == sf::Keyboard::Escape) window.close();
				break;

			default:
				break;
			}

		}
		update();
		window.clear();
		draw(window);
		window.display();
	}

	return 0;
}

